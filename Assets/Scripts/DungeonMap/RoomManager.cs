using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// Qu·∫£n l√Ω h·ªá th·ªëng Endless Room - sinh ra c√°c ph√≤ng li√™n ti·∫øp khi player di chuy·ªÉn
/// </summary>
public class RoomManager : MonoBehaviour
{
    [Header("üè† Room Configuration")]
    [Tooltip("Danh s√°ch c√°c prefab room c√≥ th·ªÉ spawn")]
    public List<GameObject> roomPrefabs = new List<GameObject>();

    [Header("üéÆ Gameplay Settings")]
    [Tooltip("S·ªë l∆∞·ª£ng room t·ªëi ƒëa ƒë∆∞·ª£c gi·ªØ active c√πng l√∫c")]
    [SerializeField] private int maxActiveRooms = 3;

    [Tooltip("V·ªã tr√≠ spawn room ƒë·∫ßu ti√™n")]
    [SerializeField] private Vector3 startPosition = Vector3.zero;

    [Header("üìä Debug Info")]
    [Tooltip("Level ƒë·ªô kh√≥ hi·ªán t·∫°i (tƒÉng d·∫ßn m·ªói room)")]
    [SerializeField] private int difficultyLevel = 1;

    [Tooltip("T·ªïng s·ªë room ƒë√£ spawn")]
    [SerializeField] private int totalRoomsSpawned = 0;

    // Private variables
    private readonly List<GameObject> activeRooms = new List<GameObject>(); // Danh s√°ch room ƒëang active
    private GameObject currentRoom; // Room hi·ªán t·∫°i player ƒëang ·ªü
    private Vector3 nextSpawnPosition; // V·ªã tr√≠ ƒë·ªÉ spawn room ti·∫øp theo (th√¥ng tin debug)

    // Singleton pattern ƒë·ªÉ d·ªÖ truy c·∫≠p t·ª´ ExitTrigger
    public static RoomManager Instance { get; private set; }

    private void Awake()
    {
        // ƒê·∫£m b·∫£o ch·ªâ c√≥ 1 RoomManager trong scene
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    private void Start()
    {
        // Ki·ªÉm tra xem c√≥ room prefab n√†o ƒë∆∞·ª£c g√°n kh√¥ng
        if (roomPrefabs == null || roomPrefabs.Count == 0)
        {
            Debug.LogError("‚ùå RoomManager: Kh√¥ng c√≥ room prefab n√†o! H√£y g√°n room prefabs v√†o list.");
            return;
        }

        // Spawn room ƒë·∫ßu ti√™n t·∫°i v·ªã tr√≠ start
        SpawnFirstRoom();
    }

    /// <summary>
    /// Spawn room ƒë·∫ßu ti√™n khi game b·∫Øt ƒë·∫ßu
    /// </summary>
    private void SpawnFirstRoom()
    {
        Debug.Log("üè† RoomManager: Spawning first room...");

        // Ch·ªçn room ƒë·∫ßu ti√™n (c√≥ th·ªÉ random ho·∫∑c fixed)
        GameObject firstRoomPrefab = roomPrefabs[0];
        if (firstRoomPrefab == null)
        {
            Debug.LogError("‚ùå RoomManager: Room prefab ƒë·∫ßu ti√™n null!");
            return;
        }

        // Spawn room t·∫°i v·ªã tr√≠ start
        GameObject firstRoom = Instantiate(firstRoomPrefab, startPosition, Quaternion.identity);
        firstRoom.name = $"Room_01_Difficulty_{difficultyLevel}";

        // Th√™m v√†o danh s√°ch active rooms
        activeRooms.Add(firstRoom);
        currentRoom = firstRoom;
        totalRoomsSpawned++;

        // Ghi log spawn ƒë·∫ßu ti√™n
        Debug.Log($"‚úÖ First room spawned at {startPosition}.");
    }

    /// <summary>
    /// Spawn room ti·∫øp theo khi player ch·∫°m exit trigger
    /// ƒê∆∞·ª£c g·ªçi t·ª´ ExitTrigger.cs
    /// </summary>
    public void SpawnNextRoom()
    {
        if (roomPrefabs == null || roomPrefabs.Count == 0)
        {
            Debug.LogError("‚ùå RoomManager: Kh√¥ng c√≥ room prefab ƒë·ªÉ spawn!");
            return;
        }

        Debug.Log($"üö™ RoomManager: Player reached exit! Spawning next room (Difficulty {difficultyLevel + 1})...");

        // TƒÉng difficulty level
        difficultyLevel++;

        // Ch·ªçn random m·ªôt room prefab
        int randomIndex = Random.Range(0, roomPrefabs.Count);
        GameObject roomPrefab = roomPrefabs[randomIndex];
        if (roomPrefab == null)
        {
            Debug.LogError("‚ùå RoomManager: Room prefab random null!");
            return;
        }

        // T√≠nh to√°n v·ªã tr√≠ spawn d·ª±a tr√™n Exit c·ªßa room hi·ªán t·∫°i v√† Entry offset c·ªßa prefab ƒë∆∞·ª£c ch·ªçn
        Vector3 spawnPos = CalculateSpawnPositionForPrefab(roomPrefab);
        nextSpawnPosition = spawnPos; // l∆∞u l·∫°i ƒë·ªÉ debug

        // Spawn room m·ªõi t·∫°i v·ªã tr√≠ ƒë√£ t√≠nh to√°n
        GameObject newRoom = Instantiate(roomPrefab, spawnPos, Quaternion.identity);
        newRoom.name = $"Room_{totalRoomsSpawned + 1:D2}_Difficulty_{difficultyLevel}";

        // Th√™m room m·ªõi v√†o active list
        activeRooms.Add(newRoom);
        currentRoom = newRoom;
        totalRoomsSpawned++;

        // Qu·∫£n l√Ω s·ªë l∆∞·ª£ng room active (x√≥a room c≈© n·∫øu c·∫ßn)
        ManageActiveRooms();

        Debug.Log($"‚úÖ New room spawned! Total rooms: {totalRoomsSpawned}, Active rooms: {activeRooms.Count}, Difficulty: {difficultyLevel}");

        // Trigger event cho c√°c system kh√°c (spawn enemies, etc.)
        OnNewRoomSpawned(difficultyLevel);
    }

    /// <summary>
    /// T√≠nh to√°n v·ªã tr√≠ spawn cho prefab ƒë∆∞·ª£c ch·ªçn d·ª±a tr√™n Exit point c·ªßa room hi·ªán t·∫°i
    /// </summary>
    /// <param name="roomPrefabToSpawn">Prefab c·ªßa room chu·∫©n b·ªã spawn</param>
    /// <returns>V·ªã tr√≠ spawn th√≠ch h·ª£p</returns>
    private Vector3 CalculateSpawnPositionForPrefab(GameObject roomPrefabToSpawn)
    {
        if (currentRoom == null)
        {
            // N·∫øu ch∆∞a c√≥ room n√†o (edge case), d√πng startPosition
            return startPosition;
        }

        // T√¨m Exit point trong room hi·ªán t·∫°i
        Transform exitPoint = FindExitPoint(currentRoom);
        if (exitPoint == null)
        {
            Debug.LogError($"‚ùå Room {currentRoom.name} kh√¥ng c√≥ Exit point! H√£y t·∫°o Empty GameObject t√™n 'Exit' trong room prefab.");
            return startPosition;
        }

        // T√¨m Entry point c·ªßa room s·∫Øp spawn
        Transform entryPoint = FindEntryPoint(roomPrefabToSpawn);
        if (entryPoint == null)
        {
            Debug.LogError($"‚ùå Room prefab {roomPrefabToSpawn.name} kh√¥ng c√≥ Entry point! H√£y t·∫°o Empty GameObject t√™n 'Entry' trong room prefab.");
            return exitPoint.position; // fallback
        }

        // T√≠nh to√°n offset t·ª´ prefab position ƒë·∫øn entry point
        Vector3 entryOffset = entryPoint.localPosition;

        // V·ªã tr√≠ spawn = Exit c·ªßa room hi·ªán t·∫°i - Entry offset c·ªßa room m·ªõi
        Vector3 spawnPos = exitPoint.position - entryOffset;

        Debug.Log($"üìç Spawn position calculated: {spawnPos} (Exit: {exitPoint.position}, Entry offset: {entryOffset})");
        return spawnPos;
    }

    /// <summary>
    /// Qu·∫£n l√Ω s·ªë l∆∞·ª£ng room active - x√≥a room c≈© nh·∫•t n·∫øu v∆∞·ª£t qu√° maxActiveRooms
    /// </summary>
    private void ManageActiveRooms()
    {
        // N·∫øu s·ªë room active v∆∞·ª£t qu√° gi·ªõi h·∫°n
        if (activeRooms.Count > maxActiveRooms)
        {
            // X√≥a room c≈© nh·∫•t (index 0)
            GameObject oldestRoom = activeRooms[0];
            activeRooms.RemoveAt(0);

            Debug.Log($"üóëÔ∏è Destroying oldest room: {oldestRoom.name}");
            Destroy(oldestRoom);
        }
    }

    /// <summary>
    /// T√¨m Exit point trong room (child object c√≥ t√™n "Exit")
    /// </summary>
    /// <param name="room">Room object ƒë·ªÉ t√¨m</param>
    /// <returns>Transform c·ªßa Exit point, null n·∫øu kh√¥ng t√¨m th·∫•y</returns>
    private Transform FindExitPoint(GameObject room)
    {
        Transform exitPoint = room.transform.Find("Exit");
        if (exitPoint == null)
        {
            // Th·ª≠ t√¨m trong children
            for (int i = 0; i < room.transform.childCount; i++)
            {
                Transform child = room.transform.GetChild(i);
                if (child.name.ToLower().Contains("exit"))
                {
                    return child;
                }
            }
        }
        return exitPoint;
    }

    /// <summary>
    /// T√¨m Entry point trong room prefab (child object c√≥ t√™n "Entry")
    /// </summary>
    /// <param name="roomPrefab">Room prefab ƒë·ªÉ t√¨m</param>
    /// <returns>Transform c·ªßa Entry point, null n·∫øu kh√¥ng t√¨m th·∫•y</returns>
    private Transform FindEntryPoint(GameObject roomPrefab)
    {
        Transform entryPoint = roomPrefab.transform.Find("Entry");
        if (entryPoint == null)
        {
            // Th·ª≠ t√¨m trong children
            for (int i = 0; i < roomPrefab.transform.childCount; i++)
            {
                Transform child = roomPrefab.transform.GetChild(i);
                if (child.name.ToLower().Contains("entry"))
                {
                    return child;
                }
            }
        }
        return entryPoint;
    }

    /// <summary>
    /// Event ƒë∆∞·ª£c g·ªçi khi room m·ªõi ƒë∆∞·ª£c spawn - c√≥ th·ªÉ d√πng ƒë·ªÉ spawn enemies, √°p d·ª•ng difficulty, etc.
    /// </summary>
    /// <param name="difficulty">Level ƒë·ªô kh√≥ hi·ªán t·∫°i</param>
    private void OnNewRoomSpawned(int difficulty)
    {
        // TODO: Implement logic based on difficulty
        // V√≠ d·ª•: spawn enemies, thay ƒë·ªïi lighting, tƒÉng reward, etc.

        Debug.Log($"üéØ Room spawned with difficulty {difficulty}. You can implement enemy spawning here!");

        // V√≠ d·ª• implementation:
        // - Spawn (difficulty * 2) enemies
        // - Increase enemy stats by (difficulty * 10%)
        // - Add special effects based on difficulty
    }

    /// <summary>
    /// Get current difficulty level (c√≥ th·ªÉ d√πng b·ªüi c√°c script kh√°c)
    /// </summary>
    public int GetCurrentDifficulty()
    {
        return difficultyLevel;
    }

    /// <summary>
    /// Get total rooms spawned (cho statistics/UI)
    /// </summary>
    public int GetTotalRoomsSpawned()
    {
        return totalRoomsSpawned;
    }

    /// <summary>
    /// Get current room (c√≥ th·ªÉ c·∫ßn cho camera follow, etc.)
    /// </summary>
    public GameObject GetCurrentRoom()
    {
        return currentRoom;
    }

    /// <summary>
    /// Reset room system (c√≥ th·ªÉ d√πng khi player ch·∫øt v√† restart)
    /// </summary>
    [ContextMenu("Reset Room System")]
    public void ResetRoomSystem()
    {
        Debug.Log("üîÑ Resetting room system...");

        // X√≥a t·∫•t c·∫£ room active
        foreach (GameObject room in activeRooms)
        {
            if (room != null)
                Destroy(room);
        }

        activeRooms.Clear();
        currentRoom = null;
        difficultyLevel = 1;
        totalRoomsSpawned = 0;
        nextSpawnPosition = Vector3.zero;

        // Spawn l·∫°i room ƒë·∫ßu ti√™n
        SpawnFirstRoom();

        Debug.Log("‚úÖ Room system reset complete!");
    }
}

/*
========================================
üõ†Ô∏è H∆Ø·ªöNG D·∫™N SETUP ENDLESS ROOM SYSTEM
========================================

üìã B∆Ø·ªöC 1: T·∫†O ROOM PREFAB
--------------------------
1. T·∫°o Empty GameObject, ƒë·∫∑t t√™n "Room_01"
2. Th√™m c√°c object con: Background, Walls, Props, Enemies, etc.
3. T·∫°o 2 Empty GameObject con:
   - "Entry": ƒêi·ªÉm b·∫Øt ƒë·∫ßu c·ªßa room (th∆∞·ªùng ·ªü b√™n tr√°i)
   - "Exit": ƒêi·ªÉm k·∫øt th√∫c c·ªßa room (th∆∞·ªùng ·ªü b√™n ph·∫£i)
4. Th√™m Collider2D (isTrigger = true) t·∫°i v·ªã tr√≠ Exit
5. Attach script ExitTrigger.cs v√†o Collider2D c·ªßa Exit
6. K√©o th·∫£ room v√†o Project ƒë·ªÉ t·∫°o prefab

üìã B∆Ø·ªöC 2: SETUP PLAYER
-----------------------
1. ƒê·∫£m b·∫£o Player c√≥ Collider2D (kh√¥ng c·∫ßn isTrigger)
2. ƒê·∫£m b·∫£o Player c√≥ tag = "Player"
3. Player ph·∫£i c√≥ th·ªÉ di chuy·ªÉn v√† va ch·∫°m v·ªõi trigger

üìã B∆Ø·ªöC 3: SETUP ROOM MANAGER
-----------------------------
1. T·∫°o Empty GameObject trong Scene, ƒë·∫∑t t√™n "RoomManager"
2. Attach script RoomManager.cs
3. Trong Inspector:
   - G√°n c√°c Room Prefab v√†o list "Room Prefabs"
   - ƒê·∫∑t "Max Active Rooms" = 3 (ho·∫∑c s·ªë kh√°c)
   - ƒê·∫∑t "Start Position" = (0, 0, 0) ho·∫∑c v·ªã tr√≠ mong mu·ªën

üìã B∆Ø·ªöC 4: TEST SYSTEM
----------------------
1. Ch·∫°y game, room ƒë·∫ßu ti√™n s·∫Ω spawn t·∫°i Start Position
2. Di chuy·ªÉn Player ƒë·∫øn Exit trigger c·ªßa room
3. Room m·ªõi s·∫Ω spawn, Entry c·ªßa room m·ªõi kh·ªõp v·ªõi Exit c·ªßa room c≈©
4. Difficulty level s·∫Ω tƒÉng d·∫ßn m·ªói room
5. Room c≈© s·∫Ω b·ªã x√≥a khi v∆∞·ª£t qu√° Max Active Rooms

üìã B∆Ø·ªöC 5: T√ôY√ù CH·ªàNH (T√ôY CH·ªåN)
---------------------------------
1. Th√™m logic spawn enemies trong OnNewRoomSpawned()
2. T·∫°o UI hi·ªÉn th·ªã difficulty level, rooms cleared, etc.
3. Th√™m effects khi spawn room m·ªõi
4. Implement save/load system cho progress
5. Th√™m boss rooms ·ªü difficulty levels ƒë·∫∑c bi·ªát

‚ö†Ô∏è L∆ØU √ù QUAN TR·ªåNG:
- Entry v√† Exit points ph·∫£i ƒë∆∞·ª£c ƒë·∫∑t ch√≠nh x√°c ƒë·ªÉ room n·ªëi ti·∫øp nhau
- Player ph·∫£i c√≥ Collider2D v√† tag "Player"
- Room prefabs ph·∫£i c√≥ Entry v√† Exit objects
- ExitTrigger ph·∫£i ƒë∆∞·ª£c ƒë·∫∑t ch√≠nh x√°c t·∫°i v·ªã tr√≠ Exit
*/